# EventLoop和EventLoopGroup

## netty的线程模型

### Reactor单线程模型

Reactor单线程模型指所有的I/O操作都在同一个NIO线程上完成。

NIO线程职责：
1. 作为NIO服务端，接受客户端的TCP连接；
2. 作为NIO客户端，向服务端发起TCP连接；
3. 读取通信对端的请求或者应答消息；
4. 向通信对端发送信息请求或者应答消息。

由于Reactor模式适用的是异步非阻塞I/O，所有I/O操作都不会导致阻塞。

单线程模式不适用于高负载、大并发地应用场景：
1. 一个NIO线程同时处理成百上千的链路，性能上午发支持；
2. 当NIO线程负载过重之后，处理速度将会变慢；
3. 可靠性问题。

### Reactor多线程模型

Reactor多线程模型有一组NIO线程来处理I/O操作。

Reactor多线程模型特点：
1. 有一个专门的NIO线程Acceptor用于监听服务端，接受客户端的TCP连接请求；
2. 网络I/O操作有一个NIO线程池负责，线程池可以采用标准JDK线程池实现，包含一个任务队列和N个可用的线程，这些NIO线程负责消息的读取、解码、编码和发送；
3. 一个NIO线程可以同时处理N条链路，但一个链路只对应一个NIO线程，防止并发操作问题。

### 主从Reactor多线程模型

主从Reactor多线程模型特点：服务端用于接受客户端连接的是一个独立的NIO线程池。

### netty的线程模型

netty处理I/O操作的reactor线程池职责如下：

1. 异步读取通信对端的数据报，发送读事件到ChannelPipeline；
2. 异步发送消息到通信对端，调用ChannelPipeline的消息发送接口；
3. 执行系统调用Task；
4. 执行定时任务Task，例如链路空闲状态监测定时任务。

I/O线程内部进行串行操作，避免多线程竞争导致性能下降。

### 最佳实践

1. 创建两个NioEventLoopGroup，用于逻辑隔离NIO Acceptor的I/O线程；
2. 尽量不要在ChannelHandler中启动用户线程；
3. 解码要放在NIO线程调用的解码Handler中进行，不要切换到用户线程中完成消息的解码；
4. 乳沟业务逻辑操作非常简单，没有复杂的业务逻辑计算，可以直接在NIO线程上完成业务逻辑编排，不需要切换到用户线程；
5. 如果业务逻辑处理复杂，不要在NIO线程上完成，建议将解码后的POJO消息封装成Task，派发到业务线程池中由业务线程执行，保证NIO线程尽快被释放。

