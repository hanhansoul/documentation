# 垃圾收集器与内存回收策略

## 概述

1. 哪些内存需要回收？
2. 什么时候回收？
3. 如何回收？

程序计数器、虚拟机栈、本地方法栈三个区域随线程创建和消亡，因此不需要过多考虑回收的问题，方法结束或线程结束时，内存自然就被回收了。垃圾回收主要关注的是java堆和方法区中的内存回收。

## 如何判断对象已经死亡

### 引用计数法

为对象添加一个引用计数器，每当有一个地方引用它是，计数器增加1，当引用失效时，计数器减少1。

java没有采用引用计数算法，因为其很难解决对象直接循环引用的问题。

### 根搜索法

以GC根对象作为起点，从这些节点向下搜索，搜索走过的路径称为引用链，当一个对象到GC根没有任何引用链时，则此对象是不可用的。

作为GC根的对象包括：
1. 虚拟机栈（栈帧的本地变量表）中的引用的对象
2. 方法区中的类静态属性引用的对象
3. 方法区中的常量引用的对象
4. 本地方法栈中JNI（Native方法）的引用的对象

### 引用

对象是否存活与对象引用有着密切的关系。

java中引用包括，四种引用的强度依次减小：
1. 强引用：如`Object obj = new Object()`，只要强引用存在，垃圾收集器永远不会回收被引用的对象。
2. 软引用：一些还有用，但并非必要的对象，对于被软引用关联的对象，在系统将要发生内存溢出异常前，会将这些对象进行二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。java中提供了SoftReference类实现软引用。
3. 弱引用：用于描述非必需对象，强度比软引用更弱，被弱引用关联的对象只能生存到下一次垃圾收集发生之前，当发生GC时，无论内存是否足够，弱引用关联的对象都会被回收掉。java中提供了WeakReference类实现弱引用。
4. 虚引用：虚引用是最弱的引用关系，一个对象是否与虚引用关联，完全不会影响其生存时间，也无法通过虚引用获取对象，虚引用的唯一目的是希望在这个对象被回收时收到一个系统通知。java提供了PhantomReference类来实现虚引用。

### 复活

根搜索法中不可达的对象也并非是必定会被回收的。一个对象是否死亡，至少要经过两次标记过程：如果对象在进行根搜索后发现没有与GC根不可达，那它将会被第一次标记并进行依次筛选，如果对象没有覆盖finalize()方法或finalize()方法已经被调用过了，则不会执行finalize()方法。否则将该对象置于F-Queue队列中，由一个低优先级的Finalizer线程依次执行队列中的finalize()方法。该执行过程不能保证finalize()被完整执行。

finalize()方法时对象逃脱死亡的最后机会，稍后GC将对F-Queue队列中的对象进行第二次标记，如果对象在finalize()方法中与GC根建立了引用链，则不会被回收，否则该对象会被垃圾收集器回收。

### 回收方法区

永久代的垃圾收集主要回收两部分内容：
1. **废弃常量**：常量池中的类、接口、方法、字段的符号引用在没有被引用时便会被清理出常量池。
2. **无用的类**：
	1. 该类的所有实例都已经被回收，即java堆中不存在该类的任何实例。
	2. 加载该类的ClassLoader已经被回收。
	3. 该类对应的Class对象没有在任何地方被引用，无法再任何地方通过反射访问该类的方法。

在大量使用反射、动态代理、CGLib等框架的场景都需要虚拟机具备类卸载的功能，保证永久代不会溢出。

## 垃圾收集算法

### 标记-清除算法

最基础的收集算法。

首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。

缺点：
1. 效率问题
2. 空间问题：标记清除后会产生大量不连续内存碎片，可能导致以后运行过程中，需要分配较大对象时无法找到足够的连续内存空间而不得不提前触发另一次垃圾收集动作。

### 复制算法

复制算法将可用内容按容量划分为相等的两块，每次只使用其中一块。每次垃圾收集时，将其中一块的存活的对象依次复制到另一块中，然后将已使用的空间依次清理掉。

优点：
1. 不会产生内存碎片
2. 实现简单、运行高效

缺点：
1. 可使用的内存空间缩小为原来的一半

现代商业虚拟机都采用这种收集算法来回收**新生代**。

将内存分为一块较大的Eden空间和两筐较小的Survivor空间，每次使用Eden和其中一块Survivor空间。当回收时，将Eden和Survivor中还存活的对象一次性拷贝到另外一块Survivor空间中，最后清理掉Eden和刚才用过的Survivor空间。Eden和Survivor的大小比例为8:1:1。

如果在回收后另外一块Survivor空间没有足够的空间存放上一次新生代手机下来的存活对象，这些对象将直接进入老年代。

### 标记-整理算法

赋值手机算法在对象存活率较高时执行的复制操作较多，效率会降低。

根据老年代的特点，一般采用“标记-整理”算法进行垃圾收集。

### 分代收集算法

根据对象存活周期的不同将内存划分为几块，一般将堆划分为新生代与老年代，然后根据不同年代的特点选择不同的垃圾回收算法。

新生代选择复制算法，老年代选择标记-整理算法。

## 内存分配与回收策略

Java中的自动内存管理最终可以归结为自动化解决两个问题：
1. 给对象分配内存；
2. 回收分配给对象的内存。

1. 新生代GC（Minor GC）：指发生在新生代的垃圾收集动作，java对象大多生命周期很短，所以Minor GC非常频繁，回收速度也一般较快。
2. 老年代GC（Major GC/Full GC）：指发生在老年代的GC，出现Major GC，经常会伴随至少一次Minor GC，Major GC一般比Minor GC慢10倍以上。

### 对象优先在Eden区分配

大多数情况下，对象在新生代Eden区中分配，当Eden区没有足够空间时将发起一次Minor GC。

### 大对象直接进入老年代

大对象是指需要大量连续内存空间的java对象，如很长的字符串或数组。

### 长期存活的对象将进入老年代

### 空间分配担保

当发生Minor GC时，虚拟机检查晋升到老年代的对象大小是否大于老年代剩余空间大小，如果大于，则直接进行一次Major GC。

1. 首先，Eden区最大，对外提供堆内存。当Eden区快要满了，则进行Minor GC，把存活对象放入 Survivor A区，清空Eden区；
2. Eden区被清空后，继续对外提供堆内存；
3. 当Eden区再次被填满，此时对Eden区和Survivor A区同时进行Minor GC，把存活对象放入Survivor B区，同时清空Eden区和Survivor A区；
4. Eden区继续对外提供堆内存，并重复上述过程，即在Eden区填满后，把Eden区和某个Survivor区的存活对象放到另一个Survivor区；
5. 当某次Minor GC后某个Survivor区被填满，且仍有对象未被复制完毕时，或者某些对象在反复存活15次左右时，则把这部分剩余对象放到老年代区；
6. 当老年代区也被填满时，进行Major GC，对老年代区进行垃圾回收。

## 垃圾收集器

一般将Java堆分为新生代和老年代，根据各个年代的特点采用最适当的收集算法。

新生代和老年代的比例通过-XX:NewRatio控制。

-XX:SurvivorRatio

- Serial收集器
- Serial Old收集器
- ParNew收集器
- Parallel Scavenge收集器
- Parallel Old收集器
- CMS收集器
- G1收集器

### Serial收集器

单线程收集器，在进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。

运行在Client模式下虚拟机默认的新生代收集器。

特点：简单而高效，没有线程交互的开销，

- 新生代：复制算法，暂停所有用户线程
- 老年代：标记-整理算法，暂停所有用户线程

### ParNew收集器

ParNew收集器其实就是Serial收集器的多线程版本，除了使用多条线程进行垃圾收集之外，其余的和Serial所有控制参数一样。在配置为CMS GC的情况下默认的新生代收集器，可以用-XX:+UseParNewGC强制指定。

优点：在多CPU的环境下可以发挥更高而效率，并且是唯一一个可以和CMS收集器搭配工作的新生代并行GC。

- 新生代：复制算法，暂停所有用户线程
- 老年代：标记-整理算法，暂停所有用户线程

适用：运行在server模式下的虚拟机首选的新生代收集器。

### Parallel Scavenge收集器

看上去和ParNew没什么区别，但是Parallel Scavenge最大的特点就是他的关注点在于**CPU的吞吐量**，吞吐量=运行代码时间/（运行代码时间+垃圾收集时间）。较高的吞吐量可以最好的利用CPU的效率。-XX:MaxGCPauseMillis配置最大垃圾收集停顿时间，-XX:GCTimeRatio配置吞吐量大小。

优点：被称为”吞吐量优先”收集器，有一个自适应调节参数（-XX:+UseAdaptiveSizePolicy），当这个参数打开后，无需手动指定新生代大小（-Xmn）、Eden和Survivor比例（-XX:SurvivorRatio）、晋升老年代年龄限制（-XX:PretenureSizeThreshold）等细节参数，虚拟机会动态调节这些参数来提供最适合的停顿时间或最大吞吐量。

适用：本身是Server级别多CPU机器上的默认GC方式，也可以通过-XX:+UseParallelGC来指定，并且可以采用-XX:ParallelGCThread来指定线程数。

### Serial Old收集器（老年代  – 串行GC）

Serial Old是Serial收集器的老年代版本，同样是一个单线程收集器，使用”标记-整理”算法。

适用：Client模式下虚拟机使用；在Server模式有两大用途：与Parallel Scavenge收集器搭配使用，作为CMS收集器的后备预案。

### Parallel Old收集器（老年代  – 并行GC）

Parallel Old是Parallel Scavenge收集器的老年代版本，为了配合Parallel Scavenge的面向吞吐量的特性而开发的对应组合。

适用：在注重吞吐量以及CPU资源敏感的场合采用。

### CMS收集器（老年代 – 并发GC）

CMS(Concurrent Mark Sweep)收集器是一种以获取**最短回收停顿时间**为目标的收集器。基于”标记-清除”算法，整个过程分为4个步骤：

1. 初始标记（CMS initial mark）
2. 并发标记（CMS concurrent mark）
3. 重新标记（CMS remark）
4. 并发清除（CMS concurrent sweep）

其中初始标记、重新标记仍然是”Stop The World”，初始标记仅仅是标记一下GC Roots能直接关联的对象，并发标记进行GC Roots Tracing的过程，重新标记为了修正并发标记期间因用户程序继续运行而导致标记产生变动的那部分对象，这个阶段停顿时间比初始标记阶段稍长一些，但比并发标记时间短。

优点：并发收集、低停顿。

适用：重视服务的响应速度、系统停顿时间和用户体验的互联网网站或者B/S系统。

- CMS收集器对CPU资源非常敏感，在CPU数量较少时性能受限。
- CMS收集器无法处理浮动垃圾，可能出现失败导致另一次Full GC的产生。
- CMS是基于标记——清除算法实现的收集器，将产生大量碎片。

### G1收集器

G1收集器是当前收集器技术最前沿成果，与之前的CMS相比有两个显著改进：
- 基于”标记-整理”算法实现收集器和精确控制停顿；
- 能够在基本不牺牲吞吐量的前提下完成低停顿的内存回收。

G1收集器可以实现在基本不牺牲吞吐量的前提下完成低停顿的内存回收，这是因为G1收集器尽力避免全区域的垃圾收集