# 虚拟机字节码执行引擎

## 概述

1. 虚拟机执行引擎：由自己实现，自行制定指令集和执行引擎的结构体系，并且能够执行那些不被硬件直接支持的指令集格式。
2. 物理机执行引擎：直接建立在处理器、硬件、指令集和操作系统层面上的。

java虚拟机规范为虚拟机字节码执行引擎这一提供了统一外观。不同虚拟机实现中，执行引擎在执行代码时可能有解释执行（通过解释器执行）和编译执行（通过即时编译器陈胜本地代码执行）两种选择或两者兼备。但从外观上来看，java虚拟机执行引擎都是一致的：输入的是字节码文件，处理过程是字节码解析的等效过程，输出的是执行结果。

## 运行时栈帧结构

栈帧是用于支持虚拟机进行方法调用和方法执行的数据结构，是虚拟机运行时数据区中的虚拟机栈的栈元素。

栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息。每一个方法的调用过程都对应这虚拟机栈中一个栈帧的入栈与出栈过程。

在活动线程中，只有栈顶的栈帧是有效的，称为当前栈帧，这个栈帧关联的方法称为当前方法。

一个栈帧的大小取决于具体的虚拟机实现。

### 局部变量表

局部变量表是一组变量值存储空间，用于存放**方法参数**和方法内部定义的**局部变量**。

局部变量表的容量已变量槽为最小单位，能够存放一个boolean、byte、char、short、int、float、reference或returnAddress类型的数据。

reference是对象引用，用于查找对象在java堆中的起始地址索引和方法区中的对象类型数据。

returnAddress是为字节码指令服务的，指向了一条字节码指令的地址。

方法执行时，虚拟机是使用局部变量表完成参数值到参数变量列表的传递过程的。如果是实例方法，那么局部变量表中第0为索引的slot默认是用于传递方法所属对象实例的引用，在方法中可以通过关键字this来访问这个隐含的参数。

超出作用域的数组能否被回收的根本原因是：局部变量表中的Slot是否还存有关于该数组对象的引用。

对于局部变量，如果定义了但没有赋初始值，那么该局部变量不能直接使用。

### 操作数栈

操作数栈是一个后入先出栈。操作数栈的每一个元素可以使任意java数据类型，包括long和double类型。

方法执行过程中，各种字节码指令向操作数栈中写入和提取内容，即入栈与出栈操作。

操作数栈中元素的数据类型与字节码指令的序列严格匹配。

### 动态连接

每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。

## 方法调用

方法调用阶段的唯一任务是确定被调用方法的版本，而不涉及方法内部的具体运行过程。

### 解析

所有方法调用中的目标方法在Class文件中都是一个常量池中的符号引用，类加载的解析阶段会将其中一部分符号引用转化为直接引用。

调用目标在程序代码写好、编译器在进行编译时就必须确定下来，这类方法的调用称为解析。

能在解析阶段确定唯一调用版本的方法：
1. 静态方法
2. 私有方法
3. 实例构造器
4. 父类方法

这些方法在类加载的时候就会把符号引用解析为该方法的直接引用，这些方法以及final方法被称为非虚方法，其他方法被称为虚方法。

解析调用是一个静态过程，在编译期完成，在类装载的解析阶段就会把涉及的符号引用全部转化为可确定的直接引用。分派调用则可能是静态的也可能是动态的。

### 分派

分派是java中实现多态特性的基础。

分派分类：
1. 静态单分派
2. 静态多分派
3. 动态单分派
4. 动态多分派

#### 静态分派

#### 动态分派

// TODO

	invokevirtual


静态多分派，动态单分派。


## 基于栈的字节码解释执行引擎

### 解释执行

### 基于栈的指令集和基于寄存器的指令集

基于栈的指令集优点是可移植性、代码相对紧凑、编译器实现更加简单等。缺点是指令数量比基于寄存器的指令集相对较多、内存访问多，导致执行速度较慢。

### 基于栈的解释器执行过程