# 读写锁实现原理

https://www.jianshu.com/p/71449a7d01af

https://www.jianshu.com/p/1161d33fc1d0

读写锁中，读取锁是共享锁，允许多个线程同时获取该锁；而写入锁时独占锁，同一时间只能有一个线程获取该锁。

Java是通过AQS实现独占锁和共享锁的。

AQS使用标记位+队列的方式，记录获取锁、竞争锁、释放锁等一些类锁操作。但更准确的说，AQS并不关心什么是锁，对于AQS来说它只是实现了一系列的用于判断资源是否可以访问的API，并且封装了在访问资源受限时，将请求访问的线程加入队列、挂起、唤醒等操作。

AQS的功能主要分为两类：独占锁和共享锁。在它的所有子类中，要么实现了它的独占功能的API，要么实现了共享功能的API，但不会同时使用两套API，即使是ReentrantReadWriteLock，也是通过两个内部类：读锁和写锁，分别使用两套API来实现的。

- 当AQS的子类实现独占功能时，如ReentrantLock，资源是否可以被访问被定义为：只要AQS的state变量不为0，并且持有锁的线程不是当前线程，那么代表资源不可访问。
- 当AQS的子类实现共享功能时，如CountDownLatch，资源是否可以被访问被定义为：只要AQS的state变量不为0，那么代表资源不可以为访问。