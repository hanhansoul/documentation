# 虚拟机类加载机制

## 概述

类加载机制：
1. 将类描述数据从Class文件加载到内存。
2. 对数据进行校验、转换解析和初始化。
3. 最终形成虚拟机可以使用的java类型。

java类型的加载和连接过程是在程序运行期间完成的，会增加性能开销，但为java应用程序提供了灵活性。

## 类加载时机

类从加载到JVM内存中，到卸载出内存为止，生命周期包括：
1. 加载
2. 验证
3. 准备
4. 解析
5. 初始化
6. 使用
7. 卸载

其中验证、准备、解析统称为连接。

加载 -> 验证 -> 准备 -> 初始化 -> 卸载这五个步骤的顺序是确定的，但为了支持java运行时绑定的特定，解析可以在初始化之后再开始。

虚拟机规定有且仅有四种情况必须立即对类进行初始化：

1. 遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令的最常见的Java代码场景是：使用new关键字实例化对象的时候、读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。
2. 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。
3. 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
4. 当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。

这四种场景被称为对一个类进行主动引用，其他所有引用类的方式都不会触发初始化，称为被动引用。

## 类加载过程

加载、验证、准备、解析和初始化。

### 加载

加载阶段：

1. 通过一个类的全限定名来获取定义此类的二进制字节流；
2. 将这个字节流所代表的的静态存储结构转换为方法区的运行时数据结构；
3. 在java堆中生成一个代表这个类的Class对象，作为方法区这些数据的访问入口。

加载阶段完成后，虚拟机外部的二进制字节流按照虚拟机所需的格式存储在方法区中，方法区中的数据存储格式由虚拟机自行定义。java堆中实例化一个Class类型对象，作为给类型数据的外部接口。

### 验证

确保Class文件中的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身安全。

1. 文件格式验证：验证字节流是否符合Class文件格式规范，并且能被当前版本的虚拟机处理；
2. 元数据验证：对字节码描述的信息进行语义分析，保证其描述的信息符合java语言规范要求；
3. 字节码验证：进行数据流和控制流分析，保证被校验类的方法在运行时不会危害虚拟机安全；
4. 符号引用验证：发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的解析阶段发生，是对常量池中各种符号引用信息进行匹配性校验。

### 准备

准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中进行分配。

1. 此时进行内存分配的仅包括类变量，即static变量，不包括实例变量；
2. 此处所说的初始值通常情况下是数据类型的零值。

### 解析

解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。

1. 符号引用：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与逊尼基的内存布局无关，引用的目标并不一定已经加载到内存中。
2. 直接引用：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用与虚拟机实现的内存布局有关，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果存在直接引用，那引用的目标必定已经在内存中存在。

解析动作主要针对类或接口、字段、类方法、接口方法四类符号引用。

#### 类或接口的解析

对于当前类D，需要将从未解析过的符号引用N解析为一个类或接口C的直接引用：

1. 如果C不是一个数组类型，那虚拟机将会把代表N的全限定名传递给D的类加载器去加载这个类C。
2. 如果C是一个数组类型，并且数组的元素类型为帝乡，那么将按照第一点的规则加载数组元素类型，接着由虚拟机生成一个代表此数组维度和元素的数组对象。
3. 如以上步骤均无异常，则C在虚拟机中实际上已经成为一个有效的类或接口了，此时还要进行符号引用验证，确定C是否具备对D的访问权限。

#### 字段解析

解析一个未被解析过的字段符号引用,首先将会对字段表中字段所属的类或接口的符号引用进行解析。如果在解析这个类或接口符号引用的过程中出现了任何异常,都会导致字段符号引用解析的失败。如果解析成功完成，那将这个字段所属的类或接口用C表示，虚拟机规范要求按照如下步骤对C进行后续字段的搜索。

1. 如果C本身就包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。
2. 否则，如果在C中实现了接口，将会按照继承关系从下往上递归搜索各个接口和它的父接口，如果接口中包含了简单名称和字段描述符都与目标相匹配的字段,则返回这个字段的直接引用，查找结束。
3. 否则，如果C不是java.lang.Object的话，将会按照继承关系从下往上递归搜索其父类，如果在父类中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用,查找结束。
4. 否则，查找失败，拋出java.lang.NoSuchFieldError异常。

#### 类方法解析

类方法解析第一个步也需要先解析出类方法表的class_index项中索引的方法所属的类或接口的符号引用，如果解析成功，我们用C表示这个类，接下来虚拟机将会按照如下步骤进行后续的类方法搜索。

1. 类方法和接口方法符号引用的常量类型定义是分开的，如果在类方法表中发现class_index中索引的C是个接口，那就直接拋出java.lang.IncompatibleClassChangeError异常。
2. 如果通过了第1步，在类C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。
3. 否则，在类C的父类中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。
4. 否则，在类C实现的接口列表及它们的父接口之中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果存在匹配的方法，说明类C是一个抽象类，这时查找结束，拋出Java.lang.AbstractMethodError异常。
5. 否则，宣告方法查找失败，拋出java.lang.NoSuchMethodError。

最后，如果查找过程成功返回了直接引用，将会对这个方法进行权限验证，如果发现不具备对此方法的访问权限，将拋出java.lang.IllegalAccessError异常。

#### 接口方法解析

// TODO

### 初始化

初始化阶段，根据程序对类变量和其他资源进行初始化。

## 类加载器

### 类与类加载器

对于任意一个类，加载它的类加载器和这个类本身一同确立了其在虚拟机中的唯一性。

### 双亲委派模型

虚拟机存在两种不同的类加载器：
1. 启动类加载器，使用C++实现，是虚拟机自身一部分；
2. 其他所有的类加载器，由Java实现，独立于虚拟机之外，继承自ClassLoader类。

类加载器还可以细分：
1. 启动类加载器：主要负载加载JAVA_HOME/lib下的类库，启动类加载器无法被应用程序直接使用。
2. 扩展类加载器：扩展类加载器是指Sun公司(已被Oracle收购)实现的sun.misc.Launcher$ExtClassLoader类，由Java语言实现的，是Launcher的静态内部类，它负责加载<JAVA_HOME>/lib/ext目录下或者由系统变量-Djava.ext.dir指定位路径中的类库，开发者可以直接使用标准扩展类加载器。
3. 应用程序类加载器：Sun公司实现的sun.misc.Launcher$AppClassLoader。它负责加载系统类路径java -classpath或-D java.class.path 指定路径下的类库，也就是我们经常用到的classpath路径，开发者可以直接使用系统类加载器，一般情况下该类加载是程序中默认的类加载器，通过ClassLoader#getSystemClassLoader()方法可以获取到该类加载器。

双亲委派模式要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。双亲委派模式中的父子关系一般不会以类继承关系实现，而是采用组合关系来复用父类加载器代码。

其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载。

双亲委派模型的优势：

对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。因此，使用双亲委派模型来组织类加载器之间的关系，有一个显而易见的好处：类随着它的类加载器一起具备了一种带有优先级的层次关系。

例如类java.lang.Object，它由启动类加载器加载。双亲委派模型保证任何类加载器收到的对java.lang.Object的加载请求，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。

相反，如果没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己编写了一个称为java.lang.Object的类，并用自定义的类加载器加载，那系统中将会出现多个不同的Object类，Java类型体系中最基础的行为也就无法保证，应用程序也将会变得一片混乱。

双亲委派模型的实现

实现代码集中在ClassLoader类的loadClass()方法中，先减产是否已经被加载过，若没有加载则调用父加载器的loadClass()方法，若父加载器为空则默认使用启动类加载器作为父加载器。如果父类加载失败，则子抛出ClassNotFoundException异常后，再调用自己的findClass()方法进行加载。

### 破坏双亲委派模型

// TODO

JNDI服务

OSGi

