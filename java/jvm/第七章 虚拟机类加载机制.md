# 虚拟机类加载机制

## 概述

类加载机制：
1. 将类描述数据从Class文件加载到内存。
2. 对数据进行校验、转换解析和初始化。
3. 最终形成虚拟机何志杰使用的java类型。

java类型的加载和连接过程是在程序运行期间完成的，会增加性能开销，但为java应用程序提供了灵活性。

## 类加载时机

类从加载到JVM内存中，到卸载出内存为止，生命周期包括：
1. 加载
2. 验证
3. 准备
4. 解析
5. 初始化
6. 使用
7. 卸载

其中验证、准备、解析统称为连接。

虚拟机规定有且仅有四种情况必须立即对类进行初始化：

1. 遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令的最常见的Java代码场景是：使用new关键字实例化对象的时候、读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。
2. 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。
3. 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
4. 当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。

这四种场景被称为对一个类进行主动引用，其他所有引用类的方式都不会触发初始化，称为被动引用。

## 类加载过程

加载、验证、准备、解析和初始化。

### 加载

加载阶段：

1. 通过一个类的全限定名来获取定义此类的我二进制字节流；
2. 将这个字节流所代表的的静态存储结构转换为方法区；
3. 在java堆中生成一个代表这个类的Class对象，作为方法区这些数据的访问入口。

加载阶段完成后，虚拟机外部的二进制字节流按照虚拟机所需的格式存储在方法区中，方法区中的数据存储格式由虚拟机自行定义。java堆中实例化一个Class类型对象，作为给类型数据的外部接口。

### 验证

确保Class文件中的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身安全。

1. 文件格式验证
2. 元数据验证
3. 字节码验证
4. 符号引用验证

### 准备

准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中进行分配。

1. 此时进行内存分配的仅包括类变量，即static变量，不包括实例变量；
2. 此处所说的初始值通常情况下是数据类型的零值。

### 解析

解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。

1. 符号引用：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与逊尼基的内存布局无关，引用的目标并不一定已经加载到内存中。
2. 直接引用：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用与虚拟机实现的内存布局有关，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果存在直接引用，那引用的目标必定已经在内存中存在。

解析动作主要针对类或接口、字段、类方法、接口方法四类符号引用。

// TODO

### 初始化

初始化阶段，根据程序对类变量和其他资源进行初始化。

## 类加载器

### 类与类加载器

对于任意一个类，加载它的类加载器和这个类本身一同确立了其在虚拟机中的唯一性。

### 双亲委派模型

虚拟机存在两种不同的类加载器：
1. 启动类加载器，使用C++实现，是虚拟机自身一部分；
2. 其他所有的类加载器，由Java实现，独立于虚拟机之外，继承自ClassLoader类。

类加载器还可以细分：
1. 启动类加载器：主要负载加载JAVA_HOME/lib下的类库，启动类加载器无法被应用程序直接使用。
2. 扩展类加载器：扩展类加载器是指Sun公司(已被Oracle收购)实现的sun.misc.Launcher$ExtClassLoader类，由Java语言实现的，是Launcher的静态内部类，它负责加载<JAVA_HOME>/lib/ext目录下或者由系统变量-Djava.ext.dir指定位路径中的类库，开发者可以直接使用标准扩展类加载器。
3. 应用程序类加载器：Sun公司实现的sun.misc.Launcher$AppClassLoader。它负责加载系统类路径java -classpath或-D java.class.path 指定路径下的类库，也就是我们经常用到的classpath路径，开发者可以直接使用系统类加载器，一般情况下该类加载是程序中默认的类加载器，通过ClassLoader#getSystemClassLoader()方法可以获取到该类加载器。

双亲委派模式要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。双亲委派模式中的父子关系一般不会以类继承关系实现，而是采用组合关系来复用父类加载器代码。

其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载。

双亲委派模型的优势：

对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。因此，使用双亲委派模型来组织类加载器之间的关系，有一个显而易见的好处：类随着它的类加载器一起具备了一种带有优先级的层次关系。

例如类java.lang.Object，它由启动类加载器加载。双亲委派模型保证任何类加载器收到的对java.lang.Object的加载请求，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。

相反，如果没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己编写了一个称为java.lang.Object的类，并用自定义的类加载器加载，那系统中将会出现多个不同的Object类，Java类型体系中最基础的行为也就无法保证，应用程序也将会变得一片混乱。

双亲委派模型的实现

实现代码集中在ClassLoader类的loadClass()方法中，先减产是否已经被加载过，若没有加载则调用父加载器的loadClass()方法，若父加载器为空则默认使用启动类加载器作为父加载器。如果父类加载失败，则子抛出ClassNotFoundException异常后，再调用自己的findClass()方法进行加载。

### 破坏双亲委派模型

// TODO

JNDI服务

OSGi

