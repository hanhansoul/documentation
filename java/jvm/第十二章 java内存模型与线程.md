# java内存模型与线程

## 概述

## 硬件效率与一致性

高速缓存：读写速度尽可能接近处理器的运算速度，作为内存与处理器之间的缓冲。

缓存一致性：多处理器系统中每个处理器都有一个缓存，而它们又共享一个内存，可能导致缓存内容不一致的情况。

## java内存模型

### 主内存与工作内存

定义程序中各个变量的访问规则，即虚拟机中将变量存储到内存和从内存中取出变量的底层细节。

变量：实例字段、静态字段、构成数组对象的元素。不包括局部变量和方法参数，因为其实线程私有的。

所有变量存储在主内存中，每条线程还有自己的工作内存，工作内存保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量。

### 内存间交互操作

### 对于volatile型变量的特殊规则

volatile是java虚拟机中提供的最轻量级的同步机制。

1. 保证volatile变量对所有线程的可见性。volatile变量对各个线程的工作内存不存在一致性问题，但并不说明它是线程安全的。
2. 禁止指令重排序优化。

### 对于long和double型变量的特殊规则

允许虚拟机将没有被volatile修饰的64位数据的读写操作划分为两次32位操作来进行，即允许虚拟机可以不保证64位数据类型的load、store、read和write四个操作的原子性。这被称为long和double的非原子性协定。

### 原子性、可见性和有序性

原子性：由java内存弄醒来直接保证原子性变量操作包括read、load、assign、use、store和write这六个。

可见性：当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。java可以通过volatile、synchronized和final关键字保证可见性。

有序性：如果本线程内观察，所有的操作都是有序的，如果在一个线程中观察另一个线程，所有操作都是无序的。

### 先行发生原则

先行发生原则是判断数据是否存在竞争，线程是否安全的主要依据。

先行发生时java内存模型中定义的两项操作之间的偏序关系，后发生的操作可以观察到先发生操作的结果，如修改了内存中共享变量的值、发送了消息、调用了方法等。

1. 程序次序规则
2. 管程锁定规则
3. volatile变量规则
4. 线程启动规则
5. 线程终止规则
6. 线程中断规则
7. 对象终结规则
8. 传递性

## java与线程

### 线程的实现

实现线程主要有三种方法：
1. 使用内核线程实现
2. 使用用户线程实现
3. 使用用户线程加轻量级进程混合实现


### java线程调度

