# 内部类1

将一个类的定义放在另一个类的定义内部，这就是内部类。

## 10.1

如果想从外部类的非静态方法之外的任意位置创建某个内部类的对象，那么必须指明这个对象的全路径类型，即OuterClassName.InnerClassName。

## 链接到外部类

当生成一个内部类的对象，并且该内部类不是静态类时，此对象能够访问其外围对象的所有成员，内部类拥有其外围类的所有元素的访问权限，就像外围对象的成员是内部类成员一样。

参考迭代器设计模式。

当某个外围类对象创建一个内部类对象时，此内部类对象必定会捕获一个指向外围类对象的引用。在访问外围类成员时，该引用就用来选择外围类的成员。

## .this与.new

当需要在内部类中引用外部类对象时，可以使用外部类的名字后紧跟“.this”的方式。这样产生的引用自动具有正确的类型，在编译期即被检查，没有任何运行时开销。

	public class Outer {
		public class Inner {
			public Outer outer() {
				return Outer.this;
			}
		}

		public Inner inner() {
			return new Inner();
		}
	}
		

有时候可能需要告知其他对象，去创建其某个内部类的对象。要实现此目的，必须在new表达式中提供对其外部类对象的引用，这就需要“.new”语法。

	public Outer {
		public class Inner() {}

		public static void main(String[] args) {
			Outer outer = new Outer();
			Outer.Inner inner = outer.new Inner();
		}
	}

当需要直接创建内部类对象时，不能直接引用外部类名字，而必须使用外部类的对象来创建该内部类对象。非静态内部类对象必须依赖于外部类对象而存在，而不能独立实例化，这是因为内部类对象会连接到它的外部类对象上。如果创建的是嵌套类，即静态内部类，则它不需要内部类对象的引用。

## 内部类与向上转型

当将内部类向上转型为其基类，特别是转型为一个接口的时候，内部类就能发挥作用了。

这是因为此内部类——某个接口的实现——能够完全不可见，并且不可用。所得到的只是指向基类或接口的引用，所以能够很方便地隐藏实现细节。

当我们将内部类的访问权限设置为protected或private时，我们就能够完全隐藏实现的细节。

注意，普通类的访问权限不能被设置为protected或private，只能被设置为public。

## 方法与作用域内的内部类

1. 实现某类型的接口，可以创建返回对其的引用。
2. 解决一个复杂的问题，需要创建一个类来辅助你的解决方案，但该类又不需要是公共可用的。

在方法或作用域中的类的类型：
1. 定义在方法中的类
2. 定义在作用域中的类，该作用域在方法的内部
3. 实现了接口的匿名类
4. 扩展了非默认构造器的匿名类
5. 执行字段初始化的匿名类
6. 通过实例初始化实现构造的匿名类

注意，匿名类不具有构造器。

## 匿名内部类

