# 泛型

泛型实现了参数化类型的概念，使代码可以应用于多种类型。

通过解耦合类或方法与所使用的类型之间的约束。

## 简单泛型

容器类是泛型的一个重要应用场景。

创建容器类时，需要指定容器中包含元素的类型。通常要求一个容器类能够存储多种不同类型的元素。

在没有泛型之前，可以指定容器的元素为Object类型，则该容器可以包含不同类型元素。

### 一个元素类库

实现一个方法调用能够返回多个对象的功能。

元素能够将一组对象直接打包存储在一个单一对象中。

## 泛型接口

泛型可以应用于接口。例如生成器，一种专门负责创建对象的类。这也是工厂方法设计模式的一种应用。使用生成器创建新对象时，不需要任何参数，而工厂方法一般需要参数。

一般而言，一个生成器只定义一个方法，该方法用以生成新的对象，如next()方法。

	public interface Generator<T> {
		T next();
	}

基本类型无法作为类型参数，但java具备自动打包和自动拆包的功能，能够方便地在基本类型与其相应的包装类型之间进行转换。

## 泛型方法

类中可以包含参数化方法，而这个方法所在的类可以是泛型类，也可以不是泛型类。是否拥有泛型方法，与其所在的类是否是泛型类无关。

泛型方法使得该方法能够独立于类而产生变化，使用泛型方法可以取代将整个类泛型化。

对于一个static的方法，其无法访问泛型类的类型参数，因此static方法需要使用泛型能力，就必须使其成为泛型方法。

定义泛型方法的方式：

	public <T> void f(T x) {

	}

使用泛型类时，必须在闯将对象的时候指定类型参数的值，而使用泛型方法时，通常不需要指明参数类型，因为编译器会通过类型参数推断确定参数类型。

### 参数推断

### 显式指定参数类型

### 可变参数与泛型方法

	public <T> void func(T... args) {
		for(T item: args) {
			// ...
		}
	}

	func(1, 2, 3, 4);

### 生成器泛型方法

## 匿名内部类

## 擦除

java泛型中，ArrayList<String>与ArrayList<Integer>是同一种类型。

Class.getTypeParameters()将返回一个TypeVariable对象数组，表示有泛型声明所声明的类型参数。但TypeVariable返回的只是用作参数占位符的标识符，并非有用的信息。

在泛型代码内部，无法获得任何有关泛型参数类型的信息。

可以知道注入类型参数标识符和泛型类型边界这类信息，但无法知道用来创建某个特定实例的实际的类型参数。

java泛型是使用擦除来实现的，因此在使用泛型时，任何具体的类型信息都被擦出了，唯一可知的就是正在使用一个对象。因此List<String>和List<Integer>在运行时事实上是相同的类型，即List类型。

通过泛型中的extend关键字，可以协助泛型类给定边界，以告知编译器遵守这个边界类型。

	<T extends Clazz>

要求泛型类T必须是Clazz类型或是Clazz的子类。

只有当你希望使用的类型参数比某个具体类型更加泛化时，使用泛型才是有意义的。

### 迁移兼容性

### 擦除的问题

即使擦除在方法或类内部移除了有关实际类型的信息，编译器仍然可以确保在方法或类中使用的类型的内部一致性。

擦除在运行时的问题就是边界：即对象进入和离开方法的位置。这正是编译器在编译期执行类型检查并插入转型代码的位置。

## 擦除的补偿

## 边界

泛型中的边界可以为泛型的参数类型设置限制条件。

由于擦除机制移除了类型信息，因此无界泛型参数调用的方法就如同使用Object调用的方法一样。使用边界机制可以将参数限制为某个类型的子集或超集，此时就可以使用对应类型子集来调用方法。

---

## 通配符

数组的一种特殊行为：可以向导出类型的数组赋予基类型的数组引用。

	<? extends Clazz>

	List<Fruit> list1 = new ArrayList<Fruit>();
	// List<Appen> list2 = list1; // compiled error
    List<? extends Fruit> list2 = list1;

泛型中的类型参数无法识别出类型间的继承关系，而泛型通配符关注的是泛型类型参数的继承关系。

泛型的通配符是在对象实例化的时候起作用的，而不是在类定义的时候。

泛型的通配符关注的是声明的对象类型与对象实例化时具体类型的关系，而不是使用对象时传入的参数或调用方法时传入参数的类型。

### 超类型通配符

	<? super Clazz>
	<T, ? super T>
	// <T super Clazz> // error

### 无界通配符

	<?>
---
http://www.importnew.com/17495.html

http://www.importnew.com/19740.html
http://www.importnew.com/24029.html
http://www.importnew.com/27037.html
http://www.importnew.com/21694.html

## 擦拭的问题

### java中不允许创建泛型数组

	List<Integer>[] arrayOfLists = new List<Integer>[2];

