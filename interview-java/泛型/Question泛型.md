Q：Java中的泛型是什么 ? 使用泛型的好处是什么?

泛型的本质是参数化类型。

1. 类型安全，提供编译器类型检测
2. 代码复用
3. 避免强制类型转换
4. 前后兼容，与旧版本java代码兼容

Q：Java的泛型是如何工作的 ? 什么是类型擦除 ?如何工作？

java中的泛型是通过擦除实现的，编译器在编译时擦除了所有类型相关的信息，所以运行时不包含任何类型相关的信息。这是为了与之前版本的java类库实现兼容。

类型擦除：泛型中的类型参数将被它们的限定类型替换。如T被替换为Object，T extends BaseClazz被替换为BaseClazz。

Q：你可以把List<String>传递给一个接受List<Object>参数的方法吗？

不行，会导致编译错误。数组类型时协变的，而泛型类型都是不可变的。

Q：如何阻止Java中的类型未检查的警告?

@SuppressWarnings(“unchecked”)

Q：Java中List<Object>和原始类型List之间的区别?

原始类型和带参数类型<Object>之间的主要区别是，在编译时编译器不会对原始类型进行类型安全检查，却会对带参数的类型进行检查，通过使用Object作为类型，可以告知编译器该方法可以接受任何类型的对象，比如String或Integer。

这道题的考察点在于对泛型中原始类型的正确理解。它们之间的第二点区别是，你可以把任何带参数的类型传递给原始类型List，但却不能把List<String>传递给接受 List<Object>的方法，因为会产生编译错误。

Q：编写一段泛型程序来实现LRU缓存?

LinkedHashMap

LinkedHashMap提供了一个称为removeEldestEntry()的方法，该方法会被put() 和putAll()调用来删除最老的键值对。

Q：Array中可以用泛型吗?

Array并不支持泛型，建议使用List来代替Array。

Q：如何编写一个泛型方法，让它能接受泛型参数并返回泛型类型？

Q：C++模板和java泛型之间有何不同？

java泛型实现根植于“类型消除”这一概念。当源代码被转换为Java虚拟机字节码时，这种技术会消除参数化类型。有了Java泛型，我们可以做的事情也并没有真正改变多少；他只是让代码变得漂亮些。鉴于此，Java泛型有时也被称为“语法糖”。

这和C++模板截然不同。在C++中，模板本质上就是一套宏指令集，只是换了个名头，编译器会针对每种类型创建一份模板代码的副本。

由于架构设计上的差异，Java泛型和C++模板有很多不同点：

C++模板可以使用int等基本数据类型。Java则不行，必须转而使用Integer。

在Java中，可以将模板的参数类型限定为某种特定类型。

在C++中，类型参数可以实例化，但java不支持。

在Java中，类型参数不能用于静态方法(?)和变量，因为它们会被不同类型参数指定的实例共享。在C++，这些类时不同的，因此类型参数可以用于静态方法和静态变量。

在Java中，不管类型参数是什么，所有的实例变量都是同一类型。类型参数会在运行时被抹去。在C++中，类型参数不同，实例变量也不同。