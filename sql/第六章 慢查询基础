# 第六章 慢查询基础

## MySQL是否在扫描额外的记录

衡量查询开销的三个指标：
1. 响应时间
2. 扫描行数
3. 返回行数

### 响应时间

响应时间分为两个部分之和：服务时间和排队时间。服务时间是指数据库处理这个查询真正花费的时间，排队时间是指服务器因为等待某些资源而没有真正执行查询的时间（如等待I/O操作完成，等待行锁等）。

### 扫描的行数与返回的行数

### 扫描的行数与访问类型

EXPLAIN语句中的type反映了访问类型，包括全表扫描、范围扫描、唯一索引扫描、常数引用等。

- 扫描表
- 扫描索引
- 范围访问
- 单值访问


WHERE条件

1. 索引中使用WHERE条件来过滤不匹配的记录，这是在存储引擎层完成的。
2. 使用索引覆盖扫描返回记录，在Extra列中出现了Using index，直接从索引中过滤不需要的记录，这是在MySQL的服务器层完成的，无须再回表查询记录。
3. 从数据表中返回数据，然后过滤不满足条件的记录，在Extra列中出现Using where，这是在MySQL服务器层完成的，MySQL需要先读出记录然后过滤。

优化查询：

1. 使用索引覆盖扫描，把所有需要用的列都放到索引中，存储引擎无须回表获取对应行就可以返回结果了。
2. 改变库表结构。
3. 重写这个复杂的查询。

### 一个复杂查询和多个简单查询

MySQL设计上对连接的建立和断开都是很轻量级的，在返回一个小的查询结果方面很高效。因此有时候将一个复杂的查询分解为多个小查询是很有必要的。

### 切分查询

### 分解关联查询

分解关联查询的优势：
1. 让缓存的效率更高。如果关联查询中某个表发生了变化，那么久无法使用查询缓存了，而如果拆分后，某个表很少发生改变，则基于该表的查询就可以重复利用查询缓存结果了。
2. 查询分解后，执行单个查询可以减少锁的竞争。
3. 在应用层做关联，可以更容易对数据库进行拆分，提高性能和可扩展性能。
4. 提高查询本身呢的效率。
5. 减少冗余记录的查询。
6. 相当于在应用中实现了哈希关联，而不是使用MySQL的嵌套循环关联。

## 查询执行的基础

MySQL执行一个查询的过程：

1. 客户端发送一条查询给服务器。
2. 服务器先检查查询缓存，如果命中则返回存储在缓存汇总的结果。
3. 服务器端进行SQL解析、预处理，再由优化器生成对应的执行计划。
4. MySQL根据优化器生成的执行计划，调用存储引擎的API执行查询。
5. 返回结果。

### MySQL的通信协议

MySQL客户端和服务器之间的通信协议是半双工的，任何时刻，要么是由服务器向客户端发送数据，要么是由客户端向服务器发送数据。

限制：无法进行流量控制，一旦一端科室发送消息，另一端要接收完整个信息才能响应它。

客户端用一个单独的数据包将查询传给服务器，一旦客户端发送了请求，就只能等待结果。

服务器响应给用户的数据通常很多，由多个数据包组成。

MySQL能够处理的优化类型
1. 重新定义关联表的顺序
2. 将外连接转化为内连接
3. 使用等价变换规则
4. 优化COUNT()、MIN()和MAX()
5. 预估并转化为常数表达式
6. 覆盖索引扫描
7. 提前终止查询
8. 等值传播
9. 列表IN()的比较，MySQL将IN()列表中的数据先进行排序，然后通过二分查找来确定列表中的值是否满足条件。