## 表锁

MySQL中最基本的并且是开销最小的锁策略。用户在对表进行写操作前，需要获得写锁，这回阻塞其他用户对该表的读写操作。只有在没有写锁时，其他读取用户才能获取读锁，读锁之间互不阻塞。

## 行锁

行锁可以最大程度地支持并发处理，同时锁开销最大。

行锁只能在存储引擎层实现，而MySQL的服务器层没有实现。

# 事务

事务的ACID特性。

1. 原子性：一个事务必须被视为一个不可分割的最小工作单元。
2. 一致性：数据库总是从一个一致性状态转换到另一个一致性状态。
3. 隔离性：一个事务所做的修改在最终提交前，其中间结果对其他事务不可见。
4. 持久性：一旦事务提交，则其所做的修改就会被永久保存到数据库中。

## 隔离级别

1. 读未提交：事务中的修改即使没有提交，对其他事务也都是可见的。事务可以读取未提交的数据，被称为脏读。
2. 读已提交：事务从开始直到提交，其所作的修改对其他事务都不可见。两次执行同样的查询可能得到不同的结果，被称为不可重复读。
3. 可重复读：当某个事务在读取某个范围内的记录时，会产生幻行，被称为幻读。
4. 序列化：最高隔离级别，强制事务串行执行，避免幻读。

## 死锁

## 事务日志

事务日志可以提高事务的效率。

## MySQL中的事务

MySQL提供了两种事务型存储引擎：InnoDB和NDB Cluster。

MySQL默认采用自动提交模式，么个查询都会被当做一个事务智信提交。

通过设置AUTOCOMMIT可以启用或禁用自动提交模式。

通过SET TRANSACTION ISOLATION LEVEL命令来设置隔离级别。

## 隐式和显式锁定

InnoDB采用两阶段锁定协议。

在事务执行过程中，随时都可以执行锁定，锁只有在执行COMMIT后者ROLLBACK的时候才会释放，并且所有锁是在同一个时刻被释放的。这属于隐式锁定。

InnoDB也支持通过特定语句进行显式锁定。

	SELECT ... LOCK INSHARE MODE

	SELECT ... FOR UDPATE

# 多版本并发控制

MySQL的大多数事务型存储引擎实现都不是简单的行级锁。基于提升性能的考虑，它们一般都同时实现了多版本并发控制（MVCC）。

MVCC是行级锁的一个变种，在很多情况下避免了加锁操作，因此开销更低。大都实现了非阻塞读操作，写操作也只锁定必要的行。

MVCC是通过保存数据在某个时间点的快照来实现的。

# 存储引擎

MySQL的每个数据库保存为数据目录下的一个子目录，MySQL在数据库子目录下创建一个和表同名的.frm文件保存表的定义。

可以使用SHOW TABLE STATUS命令显示表的相关信息。

## InnoDB

MySQL默认事务型引擎，用于处理大量的短期事务，短期事务大部分情况是正常提交，很少会回滚。

### 日志型应用

日志型应用要求数据插入速度快，开销小，MyISAM或Archive存储引擎比较合适。

如果需要对记录的日志做分析报表，生成报表的SQL可能会导致插入效率明显降低。

1. 利用MySQL内置的赋值方案将数据复制一份到备份库，然后在备份库上执行比较消耗时间和CPU的查询。
2. 在日志记录表的名字中包含年月信息，就可以在已经没有插入操作的历史表上做频繁的查询操作，而不会干扰到最新的当前表上的插入操作。

### 只读或者大部分情况只读的表

选用MyISAM存储引擎，但需要担心崩溃恢复的问题。MyISAM只是将数据写到内存中，然后等待操作系统定期将数据刷写到磁盘上。

### 订单处理

支持事务，选用InnoDB。