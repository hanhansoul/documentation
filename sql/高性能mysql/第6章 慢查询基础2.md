### 排序优化

如果需要排序的数据量小于排序缓冲区，MySQL使用内存进行快速排序操作。如果内存不够排序，MySQL会先将数据分块，对每个独立的块使用快速排序，并将各个块的排序结果存放在磁盘上，然后将各个排好序的块进行合并，最后返回排序结果。

## MySQL查询优化器的局限性

### 关联子查询

MySQL的子查询实现非常糟糕，最糟糕的一类查询时WHERE条件中包含IN()的自查询。

### UNION的限制

有时，MySQL无法将限制条件从外层下推至内层，这使得原本能够限制部分返回结果的条件无法应用到内存查询优化上。

如果希望UNION的各个子句能够根据LIMIT只取部分结果集，或者希望能够先排好序再合并结果集，就需要在UNION各个子句中分别使用这些限制条件。

### 索引合并优化

当WHERE子句中包含多个复杂条件的时候，MySQL能够访问单个表的多个索引以合并和交叉过滤的方式定位需要查找的行。

### 等值传递

### 并行执行

MySQL不支持并行执行查询。

### 哈希关联

不支持哈希关联。

### 松散索引扫描

不支持松散索引扫描。

Oracle中使用跳跃索引扫描。

### 最大值/最小值优化

基于没有索引的字段查询最大或最小值时，MySQL会采用全表查询的方式。

### 在同一张表上查询和更新

## 查询优化器的提示（hint）

如果对查询优化器选择的执行计划不满意，可以使用优化器提供的几个提示来控制最终的执行计划。

**HIGH_PRIORITY/LOW_PRIORITY**

当有多个语句同时访问某一个表的时候，哪些语句的优先级相对高些，哪些语句的优先级相对低些。

这两个提示只对使用表锁的存储引擎有效，InnoDB或其他有细粒度锁机制和并发控制的存储引擎中使用。

## 优化特定类型的查询

### 优化COUNT()查询

COUNT()作用：
1. 统计某个列值的数量，要求列值非空，即不统计NULL。如果指定了列或列的表达式，则统计的是这个表达式有值的结果数。
2. 统计结果集的行数，

MyISAM存储引擎只有没有任何WHERE条件的COUNT(\*)效率才非常高。

## 优化关联查询

1. 确保ON或者USING子句中的列上有索引。只需要在关联顺序中的第二个表的相应列上创建索引。
2. 确保任何GROUP BY和ORDER BY中的表达式只涉及到一个表中的列，这样MySQL才有可能使用索引来优化这个过程。
3. 当升级MySQL的时候需要注意：关联语法、运算符优化级等其他可能会发生变化的地方。

### 优化子查询

对于老版本的MySQL，建议尽可能使用关联查询，对于MySQL5.6及以上版本，可以忽略关于子查询的优化。

### 优化GROUP BY和DISTINCT

一般都采用索引来优化这两类查询。

无法使用索引时，GROUP BY 采用两种策略：
1. 使用临时表进行分组
2. 采用文件排序进行分组

### 优化LIMIT分页

最简单的优化方式是采用索引覆盖扫描。

