# 类型信息

运行时类型信息使得你可以在程序运行时发现和使用类型信息。

Java通过两种方式在运行时识别对象和类的类别信息：

- 传统的RTTI，它假定我们在编译时已经知道了所有的类型信息
- 反射机制，允许我们在运行时发现和使用类的信息

## RTTI

运行时对象类型识别。

## Class对象

类型信息在运行时是通过Class对象来表示的，它包含了与类有关的信息。事实上，Class独享就是用来创建类的所有常规对象的。Java使用Class对象来执行其RTTI。

每一个类都有一个Class对象，即每当编写并编译一个新类，就会产生一个Class对象，其被保存在一个同名的.class文件中。

为了生成这个类的对象，运行这个程序的JVM将使用类加载器。

类加载器子系统实际上可以包含一条加载器链，但是只有一个原生类加载器。

	Class.forName(clazzName)

forName()是Class类的一个static成员，接受包含目标类文本名的String参数作为输入，返回一个Class对象的引用。

### 类字面变量

	ClazzName.class

更加简单也更加安全，因为它在编译时就会收到检查，并且它根除了对forName()方法的调用，更加高效。

1. 加载：由类加载器执行，查找字节码，并从这些字节码中创建一个Class对象。
2. 链接：在链接阶段将验证类中的字节码，为静态域分配存储空间。
3. 初始化：如果该类具有超累，则对其初始化，执行静态初始化器与静态初始化块。

### 泛化的Class引用

## 类型转换前先做检查

1. 传统的类型转换，由RTTI确保类型转换的正确性，错误时抛出ClassCastException异常。
2. 代表对象的类型的Class对象，通过查询Class对象可以获取运行时所需的信息。
3. instanceof关键字

## instanceof与Class的等价性

instanceof或isInstance()保持了类型的概念，检查是否是这个类或这个类的子类。而使用==则不会考虑继承的情况。

## 反射

Class类与reflect类库对反射的概念进行了支持，该类库包含了Field、Method与Constructor类。这些类型的对象由JVM在运行时创建，用以表示未知类里对应的成员。

可以使用Contructor类创建新的对象，使用get()与set()方法读取和修改与Field对象关联的字段，使用invoke()方法调用Method对象关联的方法。

RTII与反射的区别是：对于RTTI来说，编译器在编译时打开和检查.class文件，而对于反射机制，.class文件在编译时是不可获取的，所以是在运行时打开和检查.class文件。

### 类方法提取器

## 动态代理

