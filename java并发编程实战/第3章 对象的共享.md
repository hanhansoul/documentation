# 对象的共享

synchronized不仅用于实现原子性或者确定临界区，同时还有内存可见性这一个重要的应用。

## 内存可见性

对于读操作和写操作在不同的线程中执行时，我们无法确保执行读操作的线程能够适时的看到其他线程写入的值。为了确保多个线程之间对内存写入操作的可见性，必须使用同步机制。

重排序。

### 失效数据

缺乏同步的程序中可能产生错误结果的一种情况：失效数据。

### 非原子的64位操作

非volatile类型的64位数值变量不满足最低安全性保证。

对于非volatile类型的long和double变量，JVM允许将64位的读写操作分解为2个32位操作。因此，在多线程程序中使用共享且可变的long和double类型变量也是不安全的，除非使用volatile声明或使用锁保护起来。

### 加锁与可见性

内置锁可以用于确保某个线程以一种可预测的方式来查看另一个线程的执行结果。

访问某个共享且可变的变量时，要求所有线程在同一个锁上同步，就是为了确保某个线程写入该变量的值对于其他线程来说都是可见的。如果一个线程在未持有正确锁的情况下读取某个变量，那么读到的可能是一个失效值。

加锁的含义不仅仅局限于互斥行为，还包括内存可见性。为确保所有线程都能看到共享变量的最新值，所有执行读操作后者写操作的线程都必须在同一个锁上同步。

### volatile变量

volatile变量是一种稍弱的同步机制，用来确保将变量的更新操作通知到其他线程。

当把变量声明为volatile类型后，编译器与运行时都会注意到该变量是共享的，因此不会将该变量上的操作和其他内存操作一起重排序。volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此读取volatile类型的变量时总会返回最新写入的值。

在访问volatile变量时不会执行加锁操作，因此不会导致线程阻塞，因此volatile变零是一种比synchronized关键字更轻量级的同步机制。

从内存可见性角度来看，写入volatile变量相当于退出同步代码块，而读取volatile变量相当于进入同步代码块。

volatile变量正确使用方法：
1. 确保变量自身状态的可见性；
2. 确保它们所引用对象的状态的可见性；
3. 标识一些重要的程序生命周期事件的发生。

	volatile boolean asleep;

	while (!asleep) {
		countSomeSheep();
	}

volatile变量不具备原子性。

加锁机制既可以确保可见性又可以确保原子性，而volatile变量只能确保可见性。

当且仅当满足以下条件时，才应该使用volatile变量：
1. 对变量的写入操作不依赖变量的当前值，或者保证只有单个线程在更新变量；
2. 该变量不会与其他状态变量一起纳入不变性条件中；
3. 在访问变量时不需要加锁。

## 发布与逸出

发布一个对象是指使对象能够在当前作用域之外的代码中使用。例如，将一个对象的引用保存到其他代码可以访问的地方，或者在一个非私有方法中返回该引用，或者姜引用传递到其他类的方法中。

当某个不应该被发布的对象被发布时，这种情况被称为逸出。

发布对象的最简单方法是将对象的引用保存到一个公有的静态变量中。

当发布一个对象时，在该对象的非私有域中引用的对象同样会被发布，如果一个已经发布的对象能够通过非私有的变量引用和方法调用到达其他的对象，那么这些对象也都会被发布。

最后一种分部对象或其内部状态的机制就是发布一个内部的类实例。

### 安全的对象构造过程

当从对象的构造函数中发布对象时，只是发布了一个尚未构造完成的对象。如果this引用在构造过程中逸出，那么这种对象就被认为是不正确构造。

不要在构造过程中使this引用逸出。

示例1：当对象在其构造函数中创建一个线程时，this引用都会被新创建的线程共享。因此在构造函数中创建线程最好不要立即启动它，而是通过一个initialize方法来启动。

示例2：如果在构造函数中注册一个事件监听器或启动线程，那么可以使用一个私有的构造函数和一个公共的工厂方法。

## 线程封闭

当访问共享的可变数据时，通常需要使用同步。一种避免使用同步的方式就是不共享数据。如果仅在单线程中访问数据，就不需要同步。

线程封闭是实现线程安全性的最简单方法之一。

线程封闭的一种常见应用是JDBC的Connection对象。

### Ad-hoc线程封闭

### 栈封闭

栈封闭中，只能通过局部变量才能访问对象。

### ThreadLocal类

维持线程封闭性的一种更规范方法是使用ThreadLocal，这个类能使线程中的某个值与保存值的对象关联起来。ThreadLocal提供了get和set等访问接口，这些方法为每个使用该变量的线程都保存了一份独立的副本，因此get总是返回由当前执行线程在调用set时设置的最新值。

ThreadLocal对象通常用于防止对可变的单实例变量或全局变量进行共享。

## 不变性

如果某个对象在被创建后其状态就不能被修改，那么这个对象就称为不可变对象。

不可变对象一定是线程安全的。

不可变性并不等于将对象中所有的域声明为final类型，即使对象中所有域都是final类型，这个对象仍然是可变的，因为在final类型的域中可以保存对可变对象的引用。

不可变性满足的条件：
1. 对象创建以后其状态就不能修改；
2. 对象的所有域都是final类型；
3. 对象时正确创建的，即创建期间this引用没有逸出。

### final域

final类型的域不能被修改，但final域引用的可变对象是可以被改变的。

java内存模型中，final域能确保初始化过程的安全性，从而可以不受限制地访问不可变对象，并在共享这些对象时无须同步。

## 安全发布

// TODO