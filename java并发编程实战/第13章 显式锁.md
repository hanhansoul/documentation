# 显式锁

## Lock与ReentrantLock

Lock提供了一种无条件的、可轮询的、定时的一级可中断的锁获取操作，所有加锁和解锁方式都是显式的。

ReentrantLock提供了互斥性和内存可见性，还提供了可重入的加锁语义。

Lock接口要求在finally块中释放锁，否则可能在抛出异常时永远无法释放这个锁。

### 轮询锁与定时锁

可定时的与可轮询的锁获取模式是由tryLock方法实现地的，与无条件的锁获取模式相比它具有更完善的错误恢复机制，可避免死锁的发生。

如果不能获得所有需要的锁，那么可以使用可定时的或可轮询的锁获取方式，从而使你重新获得控制权，它会释放已经获得的锁，然后重新尝试获取所有锁。

### 可中断的锁获取操作

定时的锁获取操作能在带有时间限制的操作中使用独占锁，可中断的锁获取操作同样能在可取消的操作中使用加锁。

### 非块结构的加锁

内置锁的获取和释放都是基于代码块的，释放锁的操作总是与获取锁的操作处于同一个代码块，而不考虑控制权如何退出代码块。自动的锁释放操作简化了对程序的分析，避免了可能的编码错误。

## 公平性

ReentrantLock的构造函数中提供了两种公平性选择：创建一个非公平的锁或者一个公平的锁。在公平的锁上，线程将按照它们发出请求的顺序来获取锁，但在非公平的锁上，则允许插队：当一个线程请求非公平的锁时，如果在发出请求时该锁的状态变为可用，那么这个线程将路过队列中所有的等待线程并获得这个锁。

统计上的公平性保证：确保被阻塞的线程能最终获得锁。

非公平锁的性能要高于公平锁的性能。

非公平锁的性能高于公平锁的一个原因是：在恢复一个被挂起的线程与该线程真正开始运行之间存在着严重的延迟。假设A持有锁，B请求锁，当A释放锁，B将被唤醒，因此会再次请求锁。此时，如果C请求锁，那么C可能会在B完全唤醒之前获得、使用以及释放这个锁。双赢：B没有推迟获得锁的时刻，C更早的获得了锁，提高了吞吐量。

当持有锁的时间相对较入，或者请求锁的平均时间间隔较长，那么应该主使用公平锁。

## 在synchronized和ReentrantLock之间进行选择

ReentrantLock在加锁和内存上提供的语义与内置锁相同，此外它提供了定时锁、轮询锁、可中断锁、公平性，以及实现非块结构的加锁。

在一些内置锁无法满足需求的情况下，ReentrantLock可以作为一种高级工具。当需要一些高级功能时才应该使用ReentrantLock，这些功能包括：可定时的、可轮询的与可中断的锁获取操作，公平队列，以及非结构的锁。否则应该优先使用synchronzied。

ReentrantLock的非块结构特性意味着，获取锁的操作不能与特定的栈帧关联起来，而内置锁却可以。

未来更可能会提升synchronzed而不是ReentrantLock的性能。因为synchronized是JVM的内置发性，它能执行一些优化，例如对线程封闭的锁对象的锁消除优化，通过增加锁的粒度来消除内置的同步，通过类库来实现的可能性不大。否则就性能方面来说，应该选择synchronized而不是ReentrantLock。

## 读写锁

ReadWriteLock中暴露了两个Lock对象，其中一个用于读操作，其中一个用于写操作。

ReentrantReadWriteLock为这两种锁都提供了可重入的加锁语义。提供公平与非公平的构造函数。在公平的锁中，等待时间最长的线程将优先获得锁。如果这个锁由读线程持有，而另一个线程请求写入锁，那么其他读线程都不能获得读取锁，直到写线程使用完毕并且释放了写入锁。在非公平的锁中，线程获得锁的顺序是不确定的。写线程降级为读线程是可以的，但从读线程升级为写线程刚是不可以的，会导致死锁。

