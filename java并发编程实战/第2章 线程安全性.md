# 第二章 线程安全性

## 什么是线程安全

当多个线程访问某个类时，这个类始终都能表现出正确的行为，就称这个类时线程安全的。

示例：一个无状态的Servlet

无状态对象既不包含任何域，也不包含任何对其他类中域的引用，计算过程中的临时状态仅在于线程栈上的局部变量中，并且只能由正在执行的线程访问。

无状态的对象一定是线程安全的。

## 原子性

在并发编程中，由于不恰当的执行时序而出现不正确的结果被称为竞态条件。

### 竞态条件

当某个计算的正确性取决于多个线程交替执行的时序时，就会发生竞态条件。

最常见的竞态条件类型为“先检查后执行”操作，即通过一个可能失效的观测结果来决定下一步的动作。

### 延迟初始化中的竞态条件

延迟初始化的目的是将对象的初始化操作推迟到实际被使用时才进行，同时确保只被初始化一次。

数据竞争：如果在访问共享的非final类型的域时没有采用同步进行协同，就会出现数据竞争。当一个线程写入一个变量而另一个线程接下来读取这个变量，或者读取一个之前由另一个线程写入的变量时，并且这两个线程之间没有使用同步，那么就可能出现数据竞争。

### 复合操作

包含了一组必须以原子方式执行的操作以确保线程安全性被称为复合操作。

锁机制是Java用于确保原子性的内置机制。

java.util.concurrent.atomic中包含一些原子变量类，用于实现在数值和对象引用上的原子状态转移。

当在无状态的类中添加一个状态时，如果该状态完全由线程安全的对象来管理，那么这个类仍是线程安全的。但当状态变量由一个变为多个时，并不会像状态变量数量由零个变为一个那样简单。

## 加锁机制

要保证状态的一致性，就需要在单个原子操作中更新所有相关的状态变量。

### 内置锁

java提供了一种内置的锁机制来支持原子性：同步代码块。

同步代码块包括两个部分：
1. 作为锁的对象引用
2. 作为由这个锁保护的代码块。

每个java对象都可以作为一个实现同步的锁，这些锁被称为内置锁或监视器锁。线程进入同步代码块之前会自动获取锁，并且在退出同步代码块时自动释放锁，无论是通过正常的控制路径退出，还是通过从代码块中抛出异常退出。获得内置锁的唯一途径就是进入由这个锁保护的同步代码块或方法。

### 重入

当某个线程请求一个由其他线程持有的锁时，发出请求的线程会阻塞。然而如果某个线程试图获得一个已经由它自己持有的锁，那么这个请求将会成功。

重入的一种实现方式：为每一个锁关联一个获取计数值和一个所有者线程。

	public class ReentrantTest implements Runnable {

	    public synchronized void get() {
	        System.out.println(Thread.currentThread().getName());
	        set();
	    }

	    public synchronized void set() {
	        System.out.println(Thread.currentThread().getName());
	    }

	    public void run() {
	        get();
	    }

	    public static void main(String[] args) {
	        ReentrantTest rt = new ReentrantTest();
	        for(;;){
	            new Thread(rt).start();
	        }
	    }
	}
