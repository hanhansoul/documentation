# 基础构建模块

## 同步容器类

1. Vector
2. Hashtable
3. Collections.synchronizedXxx()

线程安全的实现方式：将它们的状态封装起来，并对每个公有方法进行同步，使得每次只有一个线程能访问容器的状态。

### 同步容器类的问题

同步容器类都是线程安全的，但在某些情况下可能需要额外的客户端加锁来保护复合操作，如：迭代、跳转以及条件运算。但其他线程并发修改容器时，这些操作可能会出错。

### 迭代器与ConcurrentModificationException

fail-fast：当发现容器在迭代过程中被修改时，就会抛出一个ConcurrentModificationException异常。

实现方式：将计数器的变化与容器关联起来，如果在迭代期间计数器被修改，那么hasNext或next将抛出oncurrentModificationException异常。

## 并发容器

### ConcurrentHashMap

ConcurrentHashMap使用一种粒度更细的加锁机制来实现更大程度的共享，这种机制被称为分段锁机制。

1. 任意数量的读取线程可以并发地访问Map；
2. 执行读取操作的线程和执行写入操作的线程可以并发地访问Map；
3. 一定数量的写入线程可以并发地修改Map。

并发容器类的迭代器不会抛出ConcurrentModificationException。ConcurrentHashMap返回的迭代器具有弱一致性，而非“fail-fast”。弱一致性的迭代器可以容忍并发的修改。

### 额外的原子Map操作

由于ConcurrentHashMap不能被加锁来执行独占访问，因此无法使用客户端加锁来创建新的原子操作。但ConcurrentHashMap已提供了常用的原子复合操作。

### CopyOnWriteArrayList

CopyOnWriteArrayList用于替代同步List，在迭代期间不需要对容器进行加锁或复制。

CopyOnWriteArrayList线程安全性在于，只要正确地发布一个事实不可变的对象，那么在访问该对象时就不再需要进一步同步了。

每次修改都会发布一个新的容器副本，从而实现可变性。

CopyOnWriteArrayList地带起保留一个指向底层基础数组的引用，这个数组当前位于迭代器的起始位置，由于它不会被修改，因此在对其进行同步时只需确保数组内容的可见性。

CopyOnWriteArrayList返回的迭代器不会抛出ConcurrentModificationException，并且返回的元素与迭代器创建时的元素完全一致，不必考虑之后修改操作带来的影响。

## 阻塞队列和生产者-消费者模型

阻塞队列提供了可阻塞的put和take方法，以及支持定时的offer和poll方法。队列可以是有界的也可以是无界的。

阻塞队列支持生产者-消费者设计模式。

- LinkedBlockingQueue
- ArrayBlockingQueue
- PriorityBlockingQueue
- SynchronousQueue：维护一组线程，这些线程等待着把元素加入或移出队列。

### 示例：桌面扫描

### 串行线程封闭

### 双端队列与工作密取

- Deque：ArrayDeque
- BlockingDeque：LinkedBlockingDeque

在工作密取设计中，每个消费者都有各自的双端队列，如果一个消费者完成了自己双端队列中的全部工作，那么它可以从其他消费者双端队列末尾秘密地获取工作。

## 阻塞方法与中断方法

## 同步工具类

同步工具类可以使任何一个对象，只要它根据其自身的状态来协调线程的控制流。

- 阻塞队列
- 信号量
- 栅栏
- 闭锁：CountDownLatch

封装了一些状态，这些状态将决定执行同步工具类的线程是继续执行还是等待，此外还提供了一些方法对状态进行操作，以及另一些方法用于高效地等待同步工具类进入到预期状态。

### 闭锁

闭锁可以延迟线程的进度知道其到达终止状态。

闭锁的作用相当于一扇门：在闭锁到达结束状态之前，这扇门一直是关闭的，并且没有任何线程能够通过。当到达结束状态时，这扇门会打开并允许所有的线程通过。当闭锁到达结束状态后，将不会再改变状态，永远保持打开。

1. 确保某个计算在其需要的所有资源都被初始化之后才继续执行。二元闭锁可以用来表示“资源R已经被初始化”，而所有需要R的操作都必须现在这个闭锁上等待。
2. 确保某个服务在其依赖的所有其他服务都已经启动之后才启动。每个服务都有一个二元闭锁。当启动服务S时，将首先在S依赖的其他服务的闭锁上等待，在所有依赖的服务都启动后会释放闭锁S，这样其他依赖S的服务才能继续执行。
3. 等待知道某个操作的所有参与者都就绪再继续执行。

闭锁可以使一个或多个线程等待一组事件发生。闭锁的状态包括一个计数器，该计数器被初始化为一个正数，表示需要等待的事情数量。countDown方法递减计数器，表示有一个事件已经发生了，而await方法等待计数器达到零，这表示所有需要等待的事情都已经发生。如果计数器的值是非零，那么await会一直阻塞直到计数器为零，或者等待中的线程中断，或者等待超时。因此，这个工具通常用来控制线程等待，它可以让某一个线程等待直到倒计时结束，再开始执行。

### FutureTask

FutureTask也可以用做闭锁。FutureTask表示的计算是通过Callable来实现的，相当于一种可生成结果的Runnable，并且可以处于以下3种状态：

1. 等待运行
2. 正在运行
3. 运行完成

### 信号量

信号量用来控制同时访问某个特定资源的操作数量，或者同时执行某个指定操作的数量。计数信号量还可以用来实现某种资源池，或者对容器施加边界。

信号量中管理着一组虚拟的许可，许可的初始数量通过构造函数给定。在执行操作时可以首先获得许可，并在使用后释放许可。如果没有许可，那么acquire将阻塞直到有许可，release方法将返回一个许可给信号量。

信号量的一种简化形式是二值信号量，即初始值为1的信号量。二值信号量可以作为互斥体，并具备不可重入的加锁语义：谁拥有这个唯一许可，谁就拥有互斥锁。

信号量可以实现资源池，如数据库连接池（构造阻塞对象池时，BlockingQueue是一种更简单的方法）。

信号量可以将任何一种容器变为有界阻塞容器。

### 栅栏

CyclicBarrier可以使一定数量的参与方繁复在栅栏位置汇集，在并行计算中非常有用：将一个问题拆分为一系列相互独立的子问题。

// TODO

## 构建高效可伸缩的结果缓存

