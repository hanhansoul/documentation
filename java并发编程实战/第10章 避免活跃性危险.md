# 避免活跃性危险

## 死锁

当一个线程永远持有一个锁，并且其他线程都尝试获得这个锁时，那么它们将永远被阻塞。

### 锁顺序死锁

两个线程试图以不同的顺序来获得相同的锁就可能发生死锁。如果每个线程按照相同顺序来请求锁，那么就不会出现循环的加锁依赖性，也就不会产生死锁。

### 动态的锁顺序死锁

### 在协作对象之间发生的死锁

如果在持有锁的情况下调用某个外部方法，就需要警惕死锁。

### 开放调用

如果在调用某个方法时不需要持有锁，那么这种调用被称为开放调用。

在程序汇总尽可能的使用开放调用，更容易进行死锁分析。

### 资源死锁

当多个线程相互持有彼此正在等待的锁而又不释放自己已持有的锁时会发生死锁，当它们在相同的资源集合上等待时，也会发生死锁。

## 其他活跃性危险

### 饥饿

当线程由于无法访问它所需要的资源而不能继续执行时，就发生了饥饿。

引发杰的最常见资源就是CPU时钟周期。如果在java应用程序中对线程的优先级使用不当，或者再持有锁时执行一些无法结束的结构，那么也可能导致饥饿，因为其他需要这个锁的线程将无法得到它。

### 糟糕的响应性

### 活锁